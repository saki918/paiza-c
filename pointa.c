/* 「ポインタ」とは、データそのものではなく、データがある場所を指し示すものです。
C 言語では、ポインタは「アドレス」になっています。

アドレスとは、メモリ上の番地のことを指します。
コンピュータのメモリは区分けされていて、それぞれの場所には値が割り振られています。
その値がメモリ上の番地で、「アドレス」とよばれています。

ポインタを使えば、以下のようなことができます。
・アドレスの値を表示する
・ポインタの指し示す先のデータをコピーしたり、変更したりする

たとえば、ポインタを使えば、配列などのデータをコピーせずに変更することができます。 */

// ポインタを使ってみよう
#include <stdio.h>

#include <stdlib.h>
#include <time.h>

int main(void)
{
  int x = 10;
  int y = 20;

  // ポインタ変数の宣言
  int *p1, *p2;
  
  // ポインタ型の変数にアドレスを代入
  p1 = &x;
  p2 = &y;
  
  // ポインタの先の値を書き換える
  *p1 = 30;
  *p2 = 40;
  
  printf("%d\n", x);
  printf("%d\n", y);

  // 配列に対してポインタを使ってみよう
  int data[] = {1, 2, 3, 4, 5};

  int *p1, *p2;
  p1 = &data[2];
  p2 = &data[4];
  
  // そのポインタが指し示す値を参照したり書き換えたりできる
  *p1 = 30;
  *p2 = 50; 
  
  for (int i = 0; i < 5; i++) {
      printf("%d\n", data[i]);
  }

  // ポインタのアドレス確認
  int data[] = {1, 2, 3, 4, 5};

  int *p1;
  p1 = &data[2];

  /* ・ p1 の値は、data[2] 変数のアドレスになっていますが、
      ・ &p1 の値は、p1 変数そのもののアドレスなので、
        この値は data[2] 変数とは直接関係ありません。p1と*p1のアドレスは違う。 */
  printf("p1 : %p\n", p1);
  // アドレスの値を表示するには、printf の変換指定子に %p を使います。
  printf("&p1 : %p\n", &p1);

  *p1 = 30;

  for (int i = 0; i < 5; i++) {
      printf("%d\n", data[i]);
  }

  /* printf に変換指定子で %p を使ったときに表示されるアドレスの値は 16 進数になっています。

    16 進法では通常の 0 から 9 までの数字に加えて、
    アルファベットの a b c d e f
    をそれぞれ
    10 11 12 13 14 15
    と見なして、各桁を 16 個の数字で表します。

    16 進数であることをわかるようにするために、数値の前には「0x」をつけることが多いです。

    たとえば、「0x10」は 16 を表します。例 0x7ffeea7e0a80 */

  // 配列とポインタ
  /* 配列の要素を取り出すときに使用していた
  [ ] は「添字演算子」とよばれる、ポインタを扱うための演算子の 1 つです。
  添字演算子は、配列のみに使えるものではなく、
  ポインタ型の変数に対しても使うことができます。 */
  int data[] = {1, 2, 3, 4, 5};
  // 配列を表す変数は、その配列の先頭の要素へのポインタになっています。
  // たとえば、以下のプログラムを実行すると、同じアドレスが出力されます。
  printf("%p\n", data);
  printf("%p\n", &data[0]);

  // printf("data : %p\n", data);
  int *p;
  p = &data[2];

  p[2] = 50;
  
  for (int i = 0; i < 5; i++) {
      printf("data[%d] : %d\n", i, data[i]);
  }
  
  for (int i = 0; i < 3; i++) {
      printf("p[%d] : %d\n", i, p[i]);
  }

  // ポインタの配列を理解しよう
  char slime[] = "スライム";
  char dragon[] = "ドラゴン";
  char satan[] = "魔王";
  
  char *enemies[3];
  
  enemies[0] = slime;
  enemies[1] = dragon;
  enemies[2] = satan;
  
  // char *p;
  // p = &slime[0];と同様
  // p = slime;

  // printf("%s\n", slime);
  // ランダムな数を初期化するための関数 time(NULL)で現在の時刻を指定
  srand((unsigned int)time(NULL));
  int target = rand() % 3;
  printf("%s\n", enemies[0]);
  
  printf("%sに会心の一撃！ モンスターを倒した！\n", enemies[target]);

  // ポインタの間違えやすいところ
  int x = 10;
  int y = 20;
  
  int *p1;
  char *p2;
  
  // ポインタの型は、アドレスを代入する変数の型に
  // 合わせて適切に選ぶ必要があります。
  p1 = &x;
  // char型のポインタ変数にint型の変数を入れているので
  // コンパイルエラーが起きる。
  // p2 = &x;

  // 下の２行をまとめて書くとこうなる。
  int *p = &x;
  // int *p; 本当はこのように動作している
  // p = &x;
  
  // &で参照しているものに代入で書き換えることはできない。
  // 変える場合はポインタ変数を使う。
  // &x = &y; （できない）
  
  char str[] = {'a','b','c','\0'};
  
  int *p = NULL;
  /* ヌル文字とヌルポインタは違うものです。

  ・ヌル文字 ('\0') : 文字列の最後に使われる char 型の文字
  ・ヌルポインタ (NULL) : 何も指し示さないことを表す特別なポインタ
  
  文字列で、ヌル文字の代わりにヌルポインタを
  使ってしまう間違いがよくあるので、注意するようにしてください。 */
}
